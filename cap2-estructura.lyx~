#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble

\end_preamble
\use_default_options true
\master maestro-pfg.lyx
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Índice
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Estructura
\begin_inset CommandInset label
LatexCommand label
name "chap:Estructura"

\end_inset


\end_layout

\begin_layout Standard
En este capítulo se analizará brevemente cómo se organiza el código fuente
 de este proyecto y qué módulos lo conforman.
 Se tratará de guiar al lector a través de los cambios de planteamiento
 sufridos por el proyecto tras varios intentos fallidos, exponiendo las
 conclusiones de lo aprendido.
\end_layout

\begin_layout Section
Evolución
\end_layout

\begin_layout Standard
La estructura actual es resultado de varias evoluciones.
 A medida que el proyecto fue creciendo han ido surgiendo problemas y nuevas
 necesidades que no se detectaron al inicio.
 A pesar de que esta evolución fue una sucesión de pequeños cambios, en
 este proceso se pueden diferenciar a grandes rasgos tres escenarios diferentes.
 A continuación se hará un recorrido a través de los escenarios planteados
 y los motivos de su elección y abandono:
\end_layout

\begin_layout Subsection
Primer escenario
\end_layout

\begin_layout Standard
En un primer momento, después de hacer un análisis de qué herramientas usar
 pero sin plantearme en profundidad cómo iba a transcurrir el desarrollo,
 la prioridad era comenzar a trabajar y resolver los problemas sobre la
 marcha.
 La idea era centrar la mayor parte del esfuerzo en implementar el algoritmo,
 considerando que esta parte sería la más complicada, y que el resto vendría
 solo.
 Para interactuar con el software mi intención era implementar una interfaz
 gráfica muy simple y una línea de comandos.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

El lenguaje elegido sería 
\series bold
Java
\series default
 para su totalidad, haciendo uso de la librería 
\series bold
JFugue
\series default
 como base de la lógica de negocio y 
\series bold
Jenetics
\series default
 para implementar el algoritmo genético.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figs/estructura-escenario-1.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Estructura primer escenario
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esta primera aproximación fue útil para empezar a trabajar cuanto antes,
 pero a medida que iba adquiriendo mayor complejidad, comenzaban a hacerse
 notar algunas deficiencias.
 Quizá no tanto por la estructura en sí, sino por una mala implementación.
 Empecé por hacer la interfaz gráfica para poco a poco ir probando lo que
 desarrollaba, y esto resultó, a causa de mi poca experiencia, en un alto
 acoplamiento con esta interfaz, mezclando lógica de negocio en los controladore
s de las vistas y en general habiendo muchas dependencias que no debería
 haber.
 Esto cuando más lo he notado ha sido a la hora de hacer modificaciones
 o cuando me dispuse a hacer la interfaz por línea de comandos, viendo que
 estaba reescribiendo mucha lógica que ya había implementado en la interfaz
 gráfica.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

De cualquier modo, el planteamiento no era el ideal, ya que uno de mis objetivos
 iniciales era poder ampliar el proyecto en el futuro implementando otros
 algoritmos que pudieran estar en Java o en otros lenguajes y tal y como
 estaba planteado no resultaba nada cómodo.
 Por otra parte también me parecía muy interesante tratar de trasladar la
 tarea a un servidor para evitar problemas de compatibilidad, versiones,
 librerías...
 Algo que sería beneficioso tanto para mí durante el desarrollo como para
 la entrega del proyecto, haciendo que sea fácil de utilizar sin tener que
 seguir una guía de instalación.
 Es por este motivo que decidí plantearlo como un servicio web con una interfaz
 para poder utilizar desde el navegador.
\begin_inset Newline newline
\end_inset

En resumen, las 
\series bold
ventajas
\series default
 de esta estructura fueron:
\end_layout

\begin_layout Itemize
Simplicidad
\end_layout

\begin_layout Itemize
Velocidad de desarrollo
\end_layout

\begin_layout Standard
Mientras que las 
\series bold
desventajas
\series default
 fueron:
\end_layout

\begin_layout Itemize
Alto acoplamiento
\end_layout

\begin_layout Itemize
Poca flexibilidad para ampliar o modificar funcionalidades
\end_layout

\begin_layout Itemize
Dependencias con la máquina host
\end_layout

\begin_layout Subsection
Segundo escenario
\end_layout

\begin_layout Standard
Tras las deficiencias reflejadas en el primer escenario, me dispuse a tratar
 de corregirlas comenzando por independizar partes del código que no deberían
 estar unidas ya que estaban creando dependencias innecesarias y complicando
 el desarrollo.
 El objetivo principal es hacer una separación más estricta entre la interfaz
 y la lógica de negocio, el origen de la mayoría de mis problemas.
 Una vez conseguido, el siguiente paso era llevar esta independencia más
 allá, haciendo ejecutar un servicio sobre el que lanzar las tareas creadas
 por el usuario desde una interfaz que pudiera estar ubicada en la misma
 máquina o en otra distinta.
 Esta tarea resultó ser más compleja de lo que esperaba en un principio,
 para ello me guié por lo aprendido en el grado acerca de sistemas distribuidos
 y migré la estructura anterior a una aplicación cliente-servidor utilizando
 
\series bold

\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "RMI"
description "Remote Method Invocation"
literal "true"

\end_inset

JavaRMI
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
Java 
\emph on
Remote
\emph default
 
\emph on
Method
\emph default
 
\emph on
Invocation
\end_layout

\end_inset

, una solución que en un primer momento consideré que era suficiente, ya
 que más o menos lograba el resultado que quería, pero a medida que continuaba
 con el desarrollo fueron apareciendo una serie de problemas:
\end_layout

\begin_layout Itemize
No soporta otros lenguajes, algo que tenía como prioritario, ya que en paralelo
 estaba tratando de desarrollar con python una solución alternativa.
\end_layout

\begin_layout Itemize
Escasa compatibilidad utilizando clientes anteriores, con continuos problemas
 de serialización.
\end_layout

\begin_layout Itemize
Preferencia por interfaz web.
 Un cliente java seguía suponiendo una limitación.
\end_layout

\begin_layout Standard
A esto le sumaría que cuanto más acudía a internet para resolver los problemas
 puntuales que iba teniendo, más me daba cuenta de que no es la tecnología
 más actual para este propósito y que existían otras formas de implementar
 lo que quería, incluso de manera más sencilla.
 Buscando soluciones alternativas, descubrí los 
\series bold
servicios REST
\series default
, un protocolo cliente servidor algo que encajaba bastante bien con las
 necesidades del proyecto: 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Un servicio REST (Representational State Transfer) como su nombre indica,
 tiene que ver con la relación cliente-servidor y cómo se almacena el estado.
 La arquitectura REST se basa en el estilo de arquitectura cliente-servidor,
 por lo tanto las solicitudes y las respuestas se construyen sobre la base
 del proceso de transferencia de los recursos.
 Todos los recursos están identificados por un único 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "URI"
description "Unique Resource Identifier"
literal "false"

\end_inset

URI (identificador único de recursos) que normalmente representa un documento
 que captura el estado del recurso.
 Generalmente la arquitectura de estilo REST es mucho más ligera en comparación
 con 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "SOAP"
description "Simple Access Object Protocol"
literal "false"

\end_inset

SOAP, la principal alternativa.
 Por otro lado, utiliza JSON, unas cien veces más rápido que XML.
 
\begin_inset CommandInset citation
LatexCommand cite
key "halili2018web"
literal "false"

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Tras documentarme y ver implementaciones de otras personas llegué a 
\series bold
Spring
\series default
, un framework de desarrollo que me facilitó bastante las cosas, tanto para
 la creación del servicio como para la comunicación con base de datos haciendo
 uso de su soporte de 
\series bold
Hibernate
\series default
, una herramienta de mapeo de objetos a tablas para Java que facilita el
 acceso a información de una base de datos relacional pudiendo hacer consultas
 desde un nivel de abstracción más alto, sin tener que lidiar directamente
 con las conexiones ni reinventar la rueda (más detalles sobre Spring e
 Hibernate en 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Tecnologías-y-herramientas"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Probablemente lo más útil que he aprendido a lo largo de este proyecto
 a raíz de encontrar este tipo de frameworks y librerías es que cada vez
 que tenga que resolver un problema, compensa invertir algo de tiempo en
 comprobar si alguien lo ha hecho ya antes.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figs/estructura-escenario-2.svg
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Estructura segundo escenario
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Tercer escenario
\end_layout

\begin_layout Standard
El escenario anterior daba buen resultado.
 Era sencillo y efectivo, una solución válida para conseguir el objetivo.
 Sin embargo, profundizando algo más en temas de arquitectura cambió mi
 perspectiva sobre cómo debía organizar un sistema de este tipo, haciéndome
 pensar en cómo afectaría al sistema una carga de trabajo más elevada que
 correspondiera a varias personas utilizándolo y no solo yo mismo haciendo
 pruebas durante el desarrollo.
 La conclusión fue que el esquema anterior poseía varios puntos críticos
 de procesamiento que podían impactar gravemente en el usuario.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Por una parte, la interfaz web se encontraba junto con el servicio que realiza
 todas las demás operaciones.
 Esto implica que ante un colapso de dicho servicio, no podría proporcionar
 a los usuarios las páginas de la interfaz requeridas y por lo tanto, producir
 una sensación de inestabilidad.
 La primera medida a tomar fue la de separar la interfaz a un servicio independi
ente dedicado exclusivamente a esta finalidad.
 De todos modos, es cierto que la interfaz gráfica en varias situaciones
 necesita de la respuesta proporcionada por el servicio, por ejemplo para
 consultar las composiciones disponibles o para solicitar una nueva composición,
 pero en cualquier caso la sensación del usuario es más satisfactoria si
 la interfaz funciona fluida a pesar de que una tabla no logre cargar su
 contenido en un momento dado, o al realizar una acción salte una notificación
 de error.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Por otra parte, el servicio en el que se apoya la interfaz lleva a cabo
 acciones muy diversas que pueden separarse en diferentes servicios.
 En este caso, las tareas de composición son mucho más pesadas que las que
 dan respuesta al servicio REST como pueden ser consultas a base de datos.
 Haciendo una separación entre compositor y servicio REST se rebajaría drásticam
ente la carga de este último, haciendo que soporte muchos más usuarios concurren
tes sin que esto afecte a la interfaz como se comentaba en el párrafo anterior,
 ya que las acciones más pesadas se estarían ejecutando en otro módulo independi
ente.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

La separación de servicio REST y compositor me llevó al problema de cómo
 implementar el compositor de manera que no fuera bloqueante, sino que admitiera
 trabajo en paralelo y una 
\begin_inset Quotes eld
\end_inset

lista de espera
\begin_inset Quotes erd
\end_inset

 en caso de trabajar a pleno rendimiento.
 Esto me llevó a la programación dirigida por eventos, las colas de mensajería
 y Kafka.
 En resumen, un servicio de mensajería (como Apache Kafka, más información
 en 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Kafka"
plural "false"
caps "false"
noprefix "false"

\end_inset

) permite tener varias colas donde ir acumulando mensajes hasta que sean
 procesados.
 Aplicándolo al problema, el servicio REST irá acumulando especificaciones
 del usuario en la cola, y el compositor las irá sacando de ella y procesando
 en orden de llegada.
 De esta forma por muchas peticiones pendientes que tenga el compositor,
 esto no bloquea al servicio REST porque no interactúa directamente con
 él sino con Kafka que se encarga de gestionar las diferentes colas.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Esta forma de estructurar un sistema es conocida como arquitectura de microservi
cios.
 Se considera un microservicio una pequeña aplicación que puede ser desplegada,
 escalada y testeada de manera independiente.
 Otro criterio algo más difuso es que debe tener una única responsabilidad
 bien definida, lo que a veces no es tan sencillo de identificar 
\begin_inset CommandInset citation
LatexCommand cite
key "thones2015microservices"
literal "false"

\end_inset

.
 La forma más usual de manejar microservicios es mediante contenedores,
 y para ello la tecnología más popular actualmente es Docker (más información
 en 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Docker"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

En la figura 
\begin_inset CommandInset ref
LatexCommand vref
reference "esquema-estructura"
plural "false"
caps "false"
noprefix "false"

\end_inset

 se muestra cómo interactúan entre ellos cada uno de los módulos mencionados.
 Como se puede observar, el objetivo es que la totalidad del proceso se
 realice en el servidor, y que se pueda acceder al servicio a través de
 un navegador desde cualquier equipo, o incluso desde otros sistemas de
 forma sencilla si fuera necesario, desarrollando un adaptador específico
 para el API.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

A su vez, esta estructura permite una mayor flexibilidad en cuanto al balanceo
 de carga de trabajo.
 Separando el software en servicios más pequeños se pretende que estos tengan
 una funcionalidad más concreta y definida.
 Esto será importante a la hora de replicar servicios, ya que permitirá
 escalar estos módulos individualmente.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "esquema-estructura"

\end_inset


\begin_inset Graphics
	filename figs/scheme.svg
	lyxscale 50
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Estructura de los módulos en el servidor
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cada uno de los módulos correspondientes al servicio web están preparados
 para ser ejecutados en 
\emph on
Docker
\emph default
 (ver 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Docker"
plural "false"
caps "false"
noprefix "false"

\end_inset

), cada uno contiene su 
\emph on
Dockerfile
\emph default
 especificando cómo se construye su imagen, o en el caso de los módulos
 de terceros, son directamente referencias a imágenes del registro de 
\emph on
DockerHub
\emph default
.
\end_layout

\begin_layout Section
Módulos
\end_layout

\begin_layout Standard
En la sección anterior se hacía una breve introducción a la organización
 en módulos del proyecto y a como se disponen.
 En adelante, se obviarán los módulos de terceros y se hará referencia únicament
e a los que han sido desarrollados específicamente para el proyecto.
 En los próximos capítulos se profundizará más en cada uno de los módulos,
 sin embargo a continuación se van a definir las principales características
 de cada uno.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Módulo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Finalidad
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lenguaje
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Framework
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pfg-backend
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Servicio
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Spring
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pfg-frontend
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Servicio
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HTML, TS, CSS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Angular
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pfg-commons
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Librería
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pfg-composer-genetic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Servicio
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Características de cada módulo
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
pfg-commons
\series default
: Se trata del núcleo del sistema.
 Contiene el modelado de datos y la lógica de negocio común a todo el proyecto
 y está destinado a su uso como librería.
 Figura entre las dependencias del módulo pfg-backend y pfg-frontend.
\end_layout

\begin_layout Itemize

\series bold
pfg-backend
\series default
: Servicio central que actúa como coordinador del sistema.
 Comunica a los demás módulos entre sí.
 Desarrollado en Java con Spring.
\end_layout

\begin_layout Itemize

\series bold
pfg-frontend
\series default
: Interfaz gráfica de usuario en formato web, desarrollada en Angular
\end_layout

\begin_layout Itemize

\series bold
pfg-composer
\series default
:
\end_layout

\begin_layout Section
Conclusiones
\end_layout

\begin_layout Standard
Una de las prioridades que satisface este diseño es la capacidad de soportar
 alta concurrencia.
 Como se muestra en la figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "esquema-estructura"
plural "false"
caps "false"
noprefix "false"

\end_inset

 se ha optado por independizar el módulo 
\emph on
pfg-composer-genetic
\emph default
 del módulo 
\emph on
pfg-backend.
 
\emph default
El motivo de esta separación es reducir al mínimo la carga de trabajo del
 backend, cuyo correcto funcionamiento es esencial para mantener el servicio
 activo ya que es el centro del sistema, del que dependen el resto de los
 módulos.
 Por ejemplo, si el backend se viera afectado y se ralentizara, impactaría
 directamente en la interfaz web que realiza consultas sobre él vía REST
 para obtener la información a mostrar.
 De cara al usuario, una interfaz lenta es lo que da una peor sensación
 y una experiencia negativa.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Otro motivo por el que se ha optado por este modelo es la alta escalabilidad
 que proporciona.
 Al tener módulos independientes para finalidades concretas es relativamente
 sencillo multiplicar el número de instancias de cualquiera de ellos, ya
 sea por necesidades de concurrencia o por disponibilidad: 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Continuando el ejemplo anterior, en caso de que hubiera una alta demanda
 del servicio, probablemente el módulo más sobrecargado sería el 
\emph on
pfg-composer 
\emph default
ya que es el encargado de realizar las tareas más pesadas.
 Llegado el punto de necesitar más capacidad de procesamiento, bastaría
 con replicar el composer tantas veces como fuera necesario.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Otro motivo interesante por el que replicar módulos podría ser ofrecer una
 mayor disponibilidad en caso de que falle alguno de los módulos.
 En este supuesto, el más crítico sería el 
\emph on
pfg-composer.
 
\emph default
Sin él no solo no podría funcionar ninguno de los demás, sino que el usuario
 se quedaría sin 
\emph on
feedback
\emph default
 de qué está pasando.
 La interfaz no podría autenticar a los usuarios, las peticiones no se resolverí
an, y en caso de tener otros clientes como una app móvil o de escritorio,
 tampoco recibirían respuesta.
\begin_inset Newline newline
\end_inset


\end_layout

\end_body
\end_document
